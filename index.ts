import * as core from '@actions/core';
import * as github from '@actions/github';
import { GoogleGenerativeAI } from '@google/generative-ai';
import * as nodemailer from 'nodemailer';

interface ContributorInfo {
  login: string;
  email?: string;
  name?: string;
}

async function getContributorEmails(octokit: any, repoOwner: string, repoName: string): Promise<ContributorInfo[]> {
  try {
    core.info('Fetching repository contributors...');
    
    // Get contributors list
    const contributors = await octokit.paginate(octokit.rest.repos.listContributors, {
      owner: repoOwner,
      repo: repoName,
      per_page: 50
    });

    const contributorEmails: ContributorInfo[] = [];

    for (const contributor of contributors) {
      try {
        // Get user details to find public email
        const userDetails = await octokit.rest.users.getByUsername({
          username: contributor.login
        });

        const contributorInfo: ContributorInfo = {
          login: contributor.login,
          name: userDetails.data.name || contributor.login
        };

        // Only include if they have a public email
        if (userDetails.data.email) {
          contributorInfo.email = userDetails.data.email;
          contributorEmails.push(contributorInfo);
          core.info(`Found email for contributor: ${contributor.login}`);
        } else {
          core.info(`No public email found for contributor: ${contributor.login}`);
        }
      } catch (error) {
        core.warning(`Could not fetch details for contributor ${contributor.login}: ${error.message}`);
      }
    }

    core.info(`Found ${contributorEmails.length} contributors with public emails`);
    return contributorEmails;
  } catch (error) {
    core.warning(`Could not fetch contributors: ${error.message}`);
    return [];
  }
}

async function sendEmailDigest(
  summary: string, 
  contributors: ContributorInfo[], 
  repoOwner: string, 
  repoName: string
): Promise<void> {
  const emailEnabled = core.getInput('email_enabled').toLowerCase() === 'true';
  
  if (!emailEnabled) {
    core.info('Email sending is disabled');
    return;
  }

  const smtpHost = core.getInput('smtp_host');
  const smtpPort = parseInt(core.getInput('smtp_port') || '587');
  const smtpUser = core.getInput('smtp_user');
  const smtpPassword = core.getInput('smtp_password');
  const fromEmail = core.getInput('from_email');
  const fromName = core.getInput('from_name') || 'Repository Digest Bot';

  if (!smtpHost || !smtpUser || !smtpPassword || !fromEmail) {
    core.warning('Email sending is enabled but SMTP configuration is incomplete. Skipping email.');
    return;
  }

  if (contributors.length === 0) {
    core.warning('No contributors with public emails found. Skipping email.');
    return;
  }

  try {
    core.info('Setting up email transporter...');
    
    const transporter = nodemailer.createTransport({
      host: smtpHost,
      port: smtpPort,
      secure: smtpPort === 465, // true for 465, false for other ports
      auth: {
        user: smtpUser,
        pass: smtpPassword
      }
    });

    // Verify connection
    await transporter.verify();
    core.info('SMTP connection verified successfully');

    const subject = `üìä Weekly Digest for ${repoOwner}/${repoName} - ${new Date().toLocaleDateString()}`;
    
    // Convert markdown summary to HTML for better email formatting
    const htmlContent = summary
      .replace(/^# (.*$)/gm, '<h1>$1</h1>')
      .replace(/^## (.*$)/gm, '<h2>$1</h2>')
      .replace(/^### (.*$)/gm, '<h3>$1</h3>')
      .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
      .replace(/\*(.*?)\*/g, '<em>$1</em>')
      .replace(/`(.*?)`/g, '<code>$1</code>')
      .replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')
      .replace(/\n/g, '<br>');

    const emailBody = `
      <html>
        <head>
          <style>
            body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
            h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
            h2 { color: #34495e; margin-top: 30px; }
            h3 { color: #7f8c8d; }
            code { background-color: #f4f4f4; padding: 2px 4px; border-radius: 3px; }
            pre { background-color: #f8f8f8; padding: 10px; border-radius: 5px; overflow-x: auto; }
            .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; font-size: 12px; color: #666; }
          </style>
        </head>
        <body>
          ${htmlContent}
          <div class="footer">
            <p>This digest was automatically generated by the ${repoOwner}/${repoName} repository's weekly recap action.</p>
            <p>To stop receiving these emails, contact the repository maintainers.</p>
          </div>
        </body>
      </html>
    `;

    // Send to all contributors with emails
    const emailPromises = contributors.filter(c => c.email).map(async (contributor) => {
      try {
        await transporter.sendMail({
          from: `"${fromName}" <${fromEmail}>`,
          to: contributor.email,
          subject: subject,
          html: emailBody,
          text: summary // Plain text fallback
        });
        core.info(`Email sent successfully to ${contributor.login} (${contributor.email})`);
      } catch (emailError) {
        core.warning(`Failed to send email to ${contributor.login}: ${emailError.message}`);
      }
    });

    await Promise.all(emailPromises);
    core.info(`Attempted to send ${emailPromises.length} emails to contributors`);

  } catch (error) {
    core.warning(`Email sending failed: ${error.message}`);
  }
}

async function run() {
  try {
    const githubToken = core.getInput('github_token', { required: true });
    const geminiApiKey = core.getInput('gemini_api_key', { required: true });
    const repoOwner = core.getInput('repo_owner', { required: true });
    const repoName = core.getInput('repo_name', { required: true });

    const octokit = github.getOctokit(githubToken);

    // 1. Fetch contributor emails for email sending
    const contributors = await getContributorEmails(octokit, repoOwner, repoName);

    // 1. Fetch Issues
    core.info('Fetching issues...');
    const issues = await octokit.paginate(octokit.rest.issues.listForRepo, {
      owner: repoOwner,
      repo: repoName,
      state: 'all', // Get both open and closed
      per_page: 100, // Fetch up to 100 issues
    });

    // 2. Fetch Pull Requests and their diffs
    core.info('Fetching pull requests and their diffs...');
    const prs = await octokit.paginate(octokit.rest.pulls.list, {
      owner: repoOwner,
      repo: repoName,
      state: 'all', // Get both open and closed
      per_page: 50, // Limit to a reasonable number of PRs to fetch diffs for
    });

    const prsWithDiffs: Array<{ diff?: string } & typeof prs[0]> = [];
    for (const pr of prs) {
      try {
        // Fetch the full PR details including the diff
        const prDetails = await octokit.rest.pulls.get({
          owner: repoOwner,
          repo: repoName,
          pull_number: pr.number,
          mediaType: {
            format: 'diff' // Request the diff format
          }
        });
        // The diff content is directly in prDetails.data
        prsWithDiffs.push({
          ...pr,
          diff: prDetails.data.toString() // Convert the diff content to a string
        });
        core.info(`Fetched diff for PR #${pr.number}`);
      } catch (prError) {
        core.warning(`Could not fetch diff for PR #${pr.number}: ${prError.message}`);
        prsWithDiffs.push(pr); // Add PR without diff if fetching fails
      }
    }

    // 3. Fetch recent commits to main branch and their diffs
    core.info('Fetching recent commits to main and their diffs...');
    const commits = await octokit.paginate(octokit.rest.repos.listCommits, {
      owner: repoOwner,
      repo: repoName,
      sha: 'main', // Or your default branch name
      per_page: 30, // Limit to a reasonable number of recent commits to fetch diffs for
    });

    const commitsWithDiffs: Array<{ diff?: string } & typeof commits[0]> = [];
    for (const commit of commits) {
      try {
        // Fetch the full commit details including the diff
        const commitDetails = await octokit.rest.repos.getCommit({
          owner: repoOwner,
          repo: repoName,
          ref: commit.sha,
          mediaType: {
            format: 'diff' // Request the diff format
          }
        });
        // The diff content is directly in commitDetails.data
        commitsWithDiffs.push({
          ...commit,
          diff: commitDetails.data.files?.map(file => file.patch).join('\n') || '' // Extract the diff content from files and concatenate
        });
        core.info(`Fetched diff for commit ${commit.sha.substring(0, 7)}`);
      } catch (commitError) {
        core.warning(`Could not fetch diff for commit ${commit.sha.substring(0, 7)}: ${commitError.message}`);
        commitsWithDiffs.push(commit); // Add commit without diff if fetching fails
      }
    }

    // 4. Construct the prompt for Gemini
    let prompt = `
      You are a technical project manager creating a weekly digest for repository contributors and stakeholders.
      
      Analyze the following GitHub repository activity and create a comprehensive, well-structured digest that will be shared with the development team via email and discussions.
      
      **Instructions:**
      1. Provide actionable insights and highlight items that need attention
      2. Categorize items by priority (Critical, High, Medium, Low)
      3. Identify trends, patterns, and potential blockers
      4. Suggest next steps where appropriate
      5. Keep the tone professional but engaging for developers
      6. Use clear markdown formatting for email readability
      
      **Repository Data:**

      ## Issues (${issues.length} total)
      ${issues.map(issue => `
      **#${issue.number}: ${issue.title}**
      - Status: ${issue.state} | Author: @${issue.user ? issue.user.login : 'Unknown'}
      - Created: ${new Date(issue.created_at).toLocaleDateString()}
      - Description: ${issue.body ? issue.body.substring(0, 300) + (issue.body.length > 300 ? '...' : '') : 'No description provided'}
      - Labels: ${issue.labels?.map(label => typeof label === 'string' ? label : label.name).join(', ') || 'None'}
      `).join('\n')}

      ## Pull Requests (${prsWithDiffs.length} total)
      ${prsWithDiffs.map(pr => `
      **#${pr.number}: ${pr.title}**
      - Status: ${pr.state} | Author: @${pr.user ? pr.user.login : 'Unknown'}
      - Created: ${new Date(pr.created_at).toLocaleDateString()}
      - Target: ${pr.base?.ref || 'main'} ‚Üê ${pr.head?.ref || 'unknown'}
      - Description: ${pr.body ? pr.body.substring(0, 300) + (pr.body.length > 300 ? '...' : '') : 'No description provided'}
      - Files changed: ${(pr as any).changed_files || 'Unknown'} | +${(pr as any).additions || 0}/-${(pr as any).deletions || 0}
      ${pr.diff ? `- Key changes:\n\`\`\`diff\n${pr.diff.substring(0, 1500) + (pr.diff.length > 1500 ? '\n...\n' : '')}\n\`\`\`` : '- Diff not available'}
      `).join('\n')}

      ## Recent Commits (${commitsWithDiffs.length} from main branch)
      ${commitsWithDiffs.map(commit => `
      **${commit.sha.substring(0, 7)}**: ${commit.commit.message.split('\n')[0]}
      - Author: ${commit.commit.author ? commit.commit.author.name : 'Unknown'}
      - Date: ${commit.commit.author ? new Date(commit.commit.author.date).toLocaleDateString() : 'Unknown'}
      ${commit.diff ? `- Changes:\n\`\`\`diff\n${commit.diff.substring(0, 800) + (commit.diff.length > 800 ? '\n...\n' : '')}\n\`\`\`` : '- No diff available'}
      `).join('\n')}

      ---

      **Please generate a structured weekly digest with the following sections:**

      # üìä Weekly Repository Digest - ${new Date().toLocaleDateString()}

      ## üéØ Executive Summary
      [Brief overview of the week's activity and key accomplishments]

      ## üö® Priority Items Requiring Attention
      [Critical and high-priority issues, PRs that need review, blockers]

      ## üöÄ Key Developments This Week
      [Major features, bug fixes, improvements with impact assessment]

      ## üìà Activity Metrics
      [Quantitative summary: X issues opened/closed, Y PRs merged, Z commits]

      ## üë• Contributor Highlights
      [Recognize active contributors and their key contributions]

      ## üîÑ In Progress
      [Open PRs ready for review, ongoing discussions, work in progress]

      ## ‚ö†Ô∏è Issues & Blockers
      [Open issues categorized by priority with suggested actions]

      ## üìã Upcoming Focus Areas
      [Based on current activity, suggest areas that need attention next week]

      Ensure all information is accurate and based solely on the provided data. Use engaging language appropriate for a technical team while maintaining professionalism.
    `;

    // 5. Send to Gemini API for summarization
    core.info('Sending data to Gemini for summarization...');
    const genAI = new GoogleGenerativeAI(geminiApiKey);
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });

    const result = await model.generateContent(prompt);
    const summary = result.response.text();

    core.info('Summary received from Gemini.');
    core.info(summary);

    // 7. Send email digest to contributors
    await sendEmailDigest(summary, contributors, repoOwner, repoName);

    // 8. Post summary as a new discussion
    core.info('Posting summary as a new discussion...');
    const discussionTitle = `Repo Digest - ${new Date().toLocaleDateString()} for ${repoOwner}/${repoName}`;
    
    try {
      // First, fetch available discussion categories
      core.info('Fetching discussion categories...');
      const categoriesResponse = await octokit.request('GET /repos/{owner}/{repo}/discussions/categories', {
        owner: repoOwner,
        repo: repoName,
      });
      
      if (categoriesResponse.data.length === 0) {
        throw new Error('No discussion categories found. Please enable GitHub Discussions and create at least one category.');
      }
      
      // Use the first available category (typically "General")
      const categoryId = categoriesResponse.data[0].id;
      core.info(`Using discussion category: ${categoriesResponse.data[0].name} (ID: ${categoryId})`);
      
      // Create the discussion with the required category_id
      const discussionResponse = await octokit.request('POST /repos/{owner}/{repo}/discussions', {
        owner: repoOwner,
        repo: repoName,
        title: discussionTitle,
        body: summary,
        category_id: categoryId,
      });

      core.info(`Successfully created summary discussion! URL: ${discussionResponse.data.html_url}`);
      
    } catch (discussionError) {
      core.warning(`Failed to create discussion: ${discussionError.message}`);
      core.info('Discussion creation failed, but summary was successfully generated.');
      core.info('Make sure GitHub Discussions are enabled for this repository and the token has discussions:write permission.');
    }

  } catch (error) {
    core.setFailed(error.message);
  }
}

run();
